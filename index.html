<!DOCTYPE html>
<html>
<head>
    <title>WebRTC Stream</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;  /* 防止出現捲軸 */
        }
        #controls {
            padding: 10px;
            text-align: center;
        }
        #video-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }
        #video {
            width: 100%;
            height: 100%;
            object-fit: contain;  /* 保持比例並填充容器 */
        }
        #status, #resolution {
            position: absolute;
            bottom: 10px;
            left: 10px;
            font-family: monospace;
            background: rgba(0,0,0,0.5);
            color: white;
            padding: 5px;
        }
        #resolution {
            left: auto;
            right: 10px;
        }
        #error-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 5px;
            display: none;
        }
        .button {
            padding: 8px 16px;
            margin: 0 5px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        #startButton {
            background-color: #4CAF50;
            color: white;
        }
        #stopButton {
            background-color: #f44336;
            color: white;
            display: none;
        }
    </style>
</head>
<body>
    <div id="controls">
        <button id="startButton" class="button">開始串流</button>
        <button id="stopButton" class="button">停止串流</button>
    </div>
    <div id="video-container">
        <video id="video" autoplay playsinline></video>
        <div id="error-message"></div>
    </div>
    <div id="status"></div>
    <div id="resolution"></div>
    
    <script>
        const video = document.getElementById('video');
        const status = document.getElementById('status');
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const errorMessage = document.getElementById('error-message');
        let pc = null;
        let ws = null;
        let connectionTimeout = null;
        let lastFrameTime = Date.now();
        let freezeCheckInterval = null;
        const FREEZE_THRESHOLD = 3000; // 3秒無新幀視為凍結

        function showError(message) {
            errorMessage.textContent = message;
            errorMessage.style.display = 'block';
            startButton.disabled = false;
            stopButton.style.display = 'none';
            startButton.style.display = 'inline-block';
        }

        function hideError() {
            errorMessage.style.display = 'none';
        }

        async function stopStream() {
            if (freezeCheckInterval) {
                clearInterval(freezeCheckInterval);
                freezeCheckInterval = null;
            }
            
            if (ws) {
                ws.close();
                ws = null;
            }
            if (pc) {
                await pc.close();
                pc = null;
            }
            video.srcObject = null;
            startButton.disabled = false;
            startButton.style.display = 'inline-block';
            stopButton.style.display = 'none';
            hideError();
            status.textContent = 'Stream stopped';
        }

        async function startStream() {
            hideError();
            if (pc || ws) {
                await stopStream();
            }

            // Set a connection timeout
            connectionTimeout = setTimeout(() => {
                if (pc?.connectionState !== 'connected') {
                    showError('連接超時，請檢查串流來源是否可用並重試');
                    stopStream();
                }
            }, 10000); // 10 seconds timeout

            pc = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }],
                sdpSemantics: 'unified-plan',
                bundlePolicy: 'max-bundle',
                rtcpMuxPolicy: 'require'
            });

            pc.onconnectionstatechange = () => {
                console.log("Connection state:", pc.connectionState);
                status.textContent = "Connection state: " + pc.connectionState;
                if (pc.connectionState === 'connected') {
                    clearTimeout(connectionTimeout);
                    startButton.style.display = 'none';
                    stopButton.style.display = 'inline-block';
                } else if (pc.connectionState === 'failed') {
                    showError('連接失敗，請重試');
                    stopStream();
                }
            };

            pc.oniceconnectionstatechange = () => {
                console.log("ICE state:", pc.iceConnectionState);
                status.textContent += "\nICE state: " + pc.iceConnectionState;
            };

            pc.ontrack = (event) => {
                console.log("Received track:", event.track.kind);
                if (event.track.kind === 'video') {
                    video.srcObject = event.streams[0];
                    video.play().catch(e => console.error("Video play error:", e));
                    
                    // 設置視訊凍結檢測
                    setupFreezeDetection();
                }
            };
            // ip = "26.244.63.82"
            ws = new WebSocket('ws://127.0.0.1:8000/ws/webrtc/');

            ws.onopen = async () => {
                console.log("WebSocket connected");
                try {
                    const offer = await pc.createOffer({
                        offerToReceiveVideo: true,
                        offerToReceiveAudio: false
                    });
                    await pc.setLocalDescription(offer);
                    
                    ws.send(JSON.stringify({
                        type: 'offer',
                        sdp: pc.localDescription.sdp
                    }));
                } catch (e) {
                    console.error("Offer creation error:", e);
                }
            };

            ws.onmessage = async (event) => {
                const data = JSON.parse(event.data);
                console.log("Received message type:", data.type);
                
                if (data.type === 'answer') {
                    try {
                        await pc.setRemoteDescription(
                            new RTCSessionDescription({
                                type: 'answer',
                                sdp: data.sdp
                            })
                        );
                        console.log("Remote description set successfully");
                    } catch (e) {
                        console.error("Remote description error:", e);
                    }
                }
            };

            ws.onerror = (error) => {
                console.error("WebSocket error:", error);
                showError('WebSocket 連接錯誤，請重試');
                stopStream();
            };
        }

        startButton.onclick = () => {
            startButton.disabled = true;
            startStream().catch(e => {
                console.error("Start stream error:", e);
                showError('啟動串流時發生錯誤：' + e.message);
                stopStream();
            });
        };

        stopButton.onclick = () => {
            stopButton.disabled = true;
            stopStream().catch(e => {
                console.error("Stop stream error:", e);
            }).finally(() => {
                stopButton.disabled = false;
            });
        };

        // 視訊事件處理
        video.onloadedmetadata = () => {
            console.log("Video metadata loaded");
            status.textContent += "\nVideo metadata loaded";
        };

        video.onplay = () => {
            console.log("Video started playing");
            status.textContent += "\nVideo started playing";
        };

        video.onerror = (e) => {
            console.error("Video error:", e);
            status.textContent += "\nVideo error: " + e.message;
            handleStreamFreeze(); // 觸發重連
        };

        // 添加視訊凍結檢測函數
        function setupFreezeDetection() {
            // 清除現有的檢測間隔
            if (freezeCheckInterval) {
                clearInterval(freezeCheckInterval);
            }

            // 更新最後幀時間
            video.addEventListener('timeupdate', () => {
                lastFrameTime = Date.now();
            });

            // 開始檢測視訊凍結
            freezeCheckInterval = setInterval(() => {
                const currentTime = Date.now();
                if (currentTime - lastFrameTime > FREEZE_THRESHOLD) {
                    console.log("Video stream frozen, attempting to reconnect...");
                    status.textContent += "\nVideo stream frozen, reconnecting...";
                    handleStreamFreeze();
                }
            }, 1000);
        }

        // 處理視訊凍結的函�
        async function handleStreamFreeze() {
            // 清除凍結檢測間隔
            if (freezeCheckInterval) {
                clearInterval(freezeCheckInterval);
                freezeCheckInterval = null;
            }

            // 嘗試重新連接
            try {
                await stopStream();
                await new Promise(resolve => setTimeout(resolve, 1000)); // 等待1秒
                await startStream();
            } catch (e) {
                console.error("Reconnection error:", e);
                showError('重新連接失敗：' + e.message);
            }
        }
    </script>
</body>
</html>

</```rewritten_file>